- [Item 42. 익명 클래스보다는 람다를 사용해라](#item-42-익명-클래스보다는-람다를-사용해라)
- [Item 43. 람다보다는 메서드 참조를 사용해라](#item-43-람다보다는-메서드-참조를-사용해라)
- [Item 44. 표준 함수형 인터페이스를 사용해라](#item-44-표준-함수형-인터페이스를-사용해라)
- [Item 45. 스트림은 주의해서 사용해라](#item-45-스트림은-주의해서-사용해라)
- [Item 46. 스트림에서 부작용 없는 함수를 사용해라](#item-46-스트림에서-부작용-없는-함수를-사용해라)
- [Item 47. 반환 타입으로는 스트림보다 컬렉션이 낫다.](#item-47-반환-타입으로는-스트림보다-컬렉션이-낫다)
- [Item 48. 스트림 병렬화는 주의해서 사용해라](#item-48-스트림-병렬화는-주의해서-사용해라)

# Item 42. 익명 클래스보다는 람다를 사용해라

> 함수형 인터페이스를 구현할 때 1)익명 클래스 2)람다를 이용해서 구현이 가능하고
> 익명클래스를 이용하면 함수 재정의 및 인스턴스 생성의 과정이 필요
> 람다를 이용하는게 가독성, 간결성에서 이득이 있다. 그러므로 람다를 쓰자

TODO: 어떤 함수형 인터페이스가 있고
TODO: 그걸 익명클래스로 구현
TODO: 그걸 람다로 구현
TODO: 람다의 한계(이건 책 참조)

# Item 43. 람다보다는 메서드 참조를 사용해라

> 람다보다 더 간결하게 구현할 수 잇는 메서드 참조
> 메서드 참조의 유형

TODO: 람다로 구현된걸 메서드 참조로

# Item 44. 표준 함수형 인터페이스를 사용해라

> 람다표현식을 표준함수형인터페이스 변수로 선언하면 재사용성과 가독성이 증가
> 표준함수형인터페이스는 이런게 있다.

TODO: 

# Item 45. 스트림은 주의해서 사용해라
// TODO: 스트림은 항상 가독성 명확성(가능하면 실제 내 코드 리팩토링 해볼 것)
// TODO: 단계, 연산, ... 말 통일

> 스트림(데이터 시퀀스)과 스트림 파이프라인(각 원소에 대해 수행되는 연산 단계)의 정의
> 연산의 종류는 중간연산, 최종연산
> 최종연산이 호출될 때 eval되므로 lazy eval이고 최종연산이 없으면 no-op다
> 람다는 타입을 자주 생략하므로 매개변수 이름을 잘 지을 것
> char용 stream은 자바에서 지원하지 않음. chars()로 가능하지만 굳이?
> 코드블록에서만 수행가능한 걸 수행해야 한다면, 이는 스트림과 맞지않다
> > 범위 안에 지역변수 선언 및 수정
> > return, break, continue를 사용해야하는 경우
> 
> 스트림 사용하기 좋은 경우
> > 일관되게 변환
> > 필터링
> > 하나의 연산 사용
> > 컬렉션으로 모으기
> > 특정 조건 만족하는 원소 찾기
> 
> 스트림 사용하기 어려운 경우
> > 한 데이터가 파이프라인의 여러 단계를 통과할 떄, 각 단계에서 값들에 동시에 접근하기 어려운 경우? // 뭔말이래
> > 연산의 결과가 필요한 단계가 여러곳인 경우
> 
> 즉, 잘써야하고, 스트림으로 리팩토링하고 더 나아보인다면 반영하는걸 권장
> 
> 추가 내용
> > 가독성과 명확성을 위해 적절히
> > 컬렉션을 스트림으로 변환하지 마세요
> > 부작용(side-effect)가 있는 연산은 피할 것
> > 병렬 스트림은 신중히

# Item 46. 스트림에서 부작용 없는 함수를 사용해라

> 부작용이 없는 함수를 통해 명확한 동작 보장
> 최종연산에서 부작용 있는 함수 활용을 제한
> collect 메소드를 활용(toList, toSet, toMap)하여 부작용 없이 container에 저장하라
> 
> 부작용이 없는 함수.. 가 뭔데
> 스트림 패러다임의 핵심은 '계산'을 '일련의 변환'으로 재구성
> 각 단계는 이전의 입력을 받아 처리하는 **순수함수**
> > 순수함수는 오직 입력만이 결과에 영향을 주며
> > 다른 가변상태를 참조하지 않고
> > 스스로 상태를 변경하지 않는다
> 
> forEach
> > 계산결과 보여줄때만 사용.
> > 계산할때는 사용 x(TODO: 리팩토링 할거 많겠누.. // forEach 내부에서 외부변수에 막 넣고 이런거...)
> > ```java
> > Map<String, Long> freq = new HashMap<>();
> > try(Stream<String> words = new Scanner(file).tokens()) {
> >     words.forEach(word -> {
> >         freq.merge(word.toLowerCase(), 1L, Long::sum);
> >     });
> > }
> > ```
> > ```java
> > Map<String, Long> freq;
> > try(Stream<String> words = new Scanner(file).tokens()) {
> >     freq = words.collect(groupingBy(String::toLowerCase, counting()));
> > }
> > ```
>
> Collectors라는 자주 쓰는 stream API 제공(TODO: 리팩토링할거 찾아서..)
> static import해서 사용 권장
> > toList
> > toMap
> > groupingBy
> > partitionBy
> > minBy, maxBy
> > joining

# Item 47. 반환 타입으로는 스트림보다 컬렉션이 낫다.

> 걍 스트림 쓰지말고 컬렉션 쓰고
> 데이터가 크면 스트림을 써야겠지만 그때도 가능하면 컬렉션을 써라.

> 스트림 반환의 단점
> > 스트림 파이프라인을 구성해야하며 종단연산이 필수다
> 
> 컬렉션 반환의 장점
> > 추가적인 처리 없이도 원소를 바로 얻을 수 있다
> 
> 스트림 반환이 적절한 경우
> > 데이터가 매우 크거나, 지연평가가 필요하거나, 데이터가 무한이거나
> 
> 컬렉션은 Iterable의 하위타입(반복) && stream 메소드도 제공(스트림) 동시 제공
> 
> 스트림 <-> Iterable은 각각 어댑터를 통해서 변환이 가능하지만, 난잡하고 직관성이 떨어지니 쓰지 않는것을 권장
> `iterable = iterableOf(stream)` 혹은 `stream = streamOf(iterable)
> 
> 반환할 데이터가 크더라도 표현을 간결하게 할 수 있다면, 전용 컬렉션 구현을 고려하라

# Item 48. 스트림 병렬화는 주의해서 사용해라

TODO: 병렬화가 뭔지 구조(그림)부터 이해해야될듯

> 자바의 동시성 프로그래밍
> > 5: concurrent, Executor
> > 7: parallel decom-position 프레임워크 fork-join
> > 8: stream의 parallel
> 
> 동시성 프로그래밍의 주요 포인트
> > 안정성과 응답 가능 상태
> 
> 스트림에서의 동시성 프로그래밍(parallel) - 참조 지역성이 뛰어난 경우
> > 참조지역성이란 이웃한 원소가 메모리에 저장될 떄, 메모리에 연속으로 저장되는 성질
> > ArraList, HashMap, HashSet, ConcurrentHashMap, 배열, int범위, long범위
> > 이 자료구조는 데이터를 원하는 크기로 나누기 쉬워서 스레드한테 분배하기 좋고, 메모리에 올라오길 기다린느 대기시간이 작다 
> 
> 스트림에서의 동시성 프로그래밍(parallel) - 종단 연산 - 축소
> > 종단연산의 비중이 전체 파이프라인에서 크거나, 순차적 연산이라면 parallel 효과는 적다
> > reduce 메소드
> > min,max,count,sum처럼 완성된 형태로 제공되는 메소드
> > anyMatch,allMatch,noneMatch처럼 조건이 참이면 바로 반환하는 메소드
> 
> 스트림에서의 동시성 프로그래밍(parallel) - spliterator 메소드 재정의
> > 병렬화의 이점을 높이려면 spliterator를 반드시 재정의 하는게 맞다.
